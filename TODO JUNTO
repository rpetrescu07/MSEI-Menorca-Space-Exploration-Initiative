#include <TFT.h>  
#include <SPI.h>
#include <Adafruit_GPS.h>

// DEFINIR PINS
#define cs   10
#define dc   9
#define rst  8
#define GPSSerial Serial
#define GPSECHO false

// CONECTAR GPS AL PORT DE LA PLACA
Adafruit_GPS GPS(&GPSSerial);


uint32_t timer = millis();

float latitud1, longitud1, latitud2, longitud2;
float rumbo;
float operacion1;
float operacion2;
float operacion3;
float operacion4;
float incremento_longitud;
double azimut;

// create an instance of the library
TFT TFTscreen = TFT(cs, dc, rst);

// char array to print to the screen
char sensorPrintout[4];



void setup() 
{
//PANTALLA
// Put this line at the beginning of every sketch that uses the GLCD:
  TFTscreen.begin();
  TFTscreen.background(0, 0, 0);
// CREAR TEXT ESTATIC EN COLOR BLANC
  TFTscreen.stroke(255, 255, 255);
// MIDA DEL TEXT
  TFTscreen.setTextSize(2);
//QUÈ S'ESCRIU I EN QUINA POSICIÓ
  TFTscreen.text("Rumbo:\n ", 0, 0);
// ste the font size very large for the loop MIRAR DE CANVIAR AÇÒ
  TFTscreen.setTextSize(5);
}

void loop() 
//GPS+CÀLCUL
{
  char c = GPS.read();
// if you want to debug, this is a good time to do it!
  if (GPSECHO)
    if (c) Serial.print(c);// if a sentence is received, we can check the checksum, parse it...
  if (GPS.newNMEAreceived()) {
// a tricky thing here is if we print the NMEA sentence, or data
// we end up not listening and catching other sentences!
// so be very wary if using OUTPUT_ALLDATA and trying to print out data
  Serial.print(GPS.lastNMEA()); // this also sets the newNMEAreceived() flag to false
  if (!GPS.parse(GPS.lastNMEA())) // this also sets the newNMEAreceived() flag to false
    return; // we can fail to parse a sentence in which case we should just wait for another
  }
// approximately every 2 seconds or so, print out the current stats
  if (millis() - timer > 2000) {
  timer = millis(); // reset the timer
  Serial.print("\nTime: ");
  if (GPS.hour < 10) { Serial.print('0'); }
  Serial.print(GPS.hour, DEC); Serial.print(':');
  if (GPS.minute < 10) { Serial.print('0'); }
  Serial.print(GPS.minute, DEC); Serial.print(':');
  if (GPS.seconds < 10) { Serial.print('0'); }
  Serial.print(GPS.seconds, DEC); Serial.print('.');
  if (GPS.milliseconds < 10) {
  Serial.print("00");
  } else if (GPS.milliseconds > 9 && GPS.milliseconds < 100) {
  Serial.print("0");
  }
  Serial.println(GPS.milliseconds);
  Serial.print("Date: ");
  Serial.print(GPS.day, DEC);
  Serial.print(GPS.month, DEC);
  Serial.println(GPS.year, DEC);
  Serial.print("Fix: "); Serial.print((int)GPS.fix);
  Serial.print(" quality: "); Serial.println((int)GPS.fixquality);
    if (GPS.fix) {Serial.print("Location: ");
    float declatitud = (GPS.latitude*100);
    float declongitud = (GPS.longitude*100);

  Serial.print(declatitud); Serial.print(GPS.lat);
  Serial.print(", ");
  Serial.print(declongitud); Serial.println(GPS.lon);
  Serial.print("Speed (knots): "); Serial.println(GPS.speed);
  Serial.print("Angle: "); Serial.println(GPS.angle);
  Serial.print("Altitude: "); Serial.println(GPS.altitude);
  Serial.print("Satellites: "); Serial.println((int)GPS.satellites);
  Serial.print("Antenna status: "); Serial.println((int)GPS.antenna);

//Açò és la part que haurem de canviar per les longituds i latiduds que arribin
// Obtener datos desde el Monitor Serie (entrada)
//Serial.println("Ingresa la latitud del punt 1:");
  while (!Serial.available()); // Esperar a que haya datos disponibles
  latitud1 = declatitud; // Leer la longitud 1

//Serial.println("Ingresa la longitud del punt 1:");
  while (!Serial.available()); // Esperar a que haya datos disponibles
  longitud1 = declongitud; // Leer la latitud1
    
//Serial.println("Ingresa la longitud del punt 2:");
  while (!Serial.available()); // Esperar a que haya datos disponibles
  latitud2 = 395271.72; // Leer la longitud 2
    
//Serial.println("Ingresa la latitud del punt 2:");
  while (!Serial.available()); // Esperar a que haya datos disponibles
  longitud2 = 21725.60; // Leer la latitud2
    
  Serial.println(latitud2);

// Conversió radians
  operacion1 = (float) latitud1*(PI/180);
  operacion2 = (float) longitud1*(PI/180);
  operacion3 = (float) latitud2*(PI/180);
  operacion4 = (float) longitud2*(PI/180);
      
//increment longitud
  incremento_longitud = (float) operacion3 - operacion1;
      
//azimut
  float x = (sin(incremento_longitud/10000));
  float y = cos(operacion2/10000)*tan(operacion4/10000)-sin(operacion2/10000)*cos(incremento_longitud/10000);
  azimut = atan2(y, x); // Slope Y, Slope X
    
  Serial.print("azimut x es: ");
  Serial.println(x);
  Serial.print("azimut y es: ");
  Serial.println(y);
  Serial.print("Azimut: ");
  Serial.println(azimut);
//convertir azimut a grados
  rumbo = azimut*(180/PI);  
// Mostrar resultados
  Serial.print("El rumbo ideal sería: ");
  Serial.println(rumbo);

  Serial.print("Latitud 1 en radianes: ");
  Serial.println(operacion1);
  Serial.print("Longitud 1 en radianes: ");
  Serial.println(operacion2);
  Serial.print("Latitud 2 en radianes: ");
  Serial.println(operacion3);
  Serial.print("Longitud 2 en radianes: ");
  Serial.println(operacion4);

//PANTALLA
//AQUI S'HA DE CANVIAR ANALOGREAD PEL RESULTAT DEL CÀLCUL DEL RUMBO
  String sensorVal = String(rumbo);
  // convert the reading to a char array
  sensorVal.toCharArray(sensorPrintout, 7);
  // set the font color
  TFTscreen.stroke(255, 255, 255);
  // print the sensor value
  TFTscreen.text(sensorPrintout, 0, 16);
  // wait for a moment
  delay(250);
  // erase the text you just wrote
  TFTscreen.stroke(0, 0, 0);
  TFTscreen.text(sensorPrintout, 0, 16);
}
}
}
